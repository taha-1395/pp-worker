{
  "version": 3,
  "sources": ["../_worker.js"],
  "sourceRoot": "minify",
  "sourcesContent": ["import { connect } from 'cloudflare:sockets';\r\n// t.me/P_tech2024 \r\n// How to generate your own UUID:\r\n// [Windows] Press \"Win + R\", input cmd and run:  Powershell -NoExit -Command \"[guid]::NewGuid()\"\r\nlet userID = '2cd61524-9843-43ab-8a0a-df4a744bb859';\r\n\r\nconst proxyIPs = ['mtn.ircf.space', 'mkh.ircf.space', 'mci.ircf.space', 'rtl.ircf.space'];\r\nlet proxyIP = proxyIPs[Math.floor(Math.random() * proxyIPs.length)];\r\n\r\nlet dohURL = 'https://1.1.1.1/dns-query';\r\n// (dohURL) list :\r\n// https://cloudflare-dns.com/dns-query\r\n// https://dns.google/dns-query\r\n// https://sky.rethinkdns.com/1:-Pf_____9_8A_AMAIgE8kMABVDDmKOHTAKg=\r\n// https://free.shecan.ir/dns-query        <--- \u062F\u06CC \u0627\u0646 \u0627\u0633 \u0627\u06CC\u0631\u0627\u0646\u06CC\r\n\r\n// v2board api environment variables (optional)\r\n// now deprecated, please use planetscale.com instead\r\nlet nodeId = ''; // 1\r\n\r\nlet apiToken = ''; //abcdefghijklmnopqrstuvwxyz123456\r\n\r\nlet apiHost = ''; // api.v2board.com\r\n\r\nif (!isValidUUID(userID)) {\r\n\tthrow new Error('uuid is invalid');\r\n}\r\n\r\nexport default {\r\n\t/**\r\n\t * @param {import(\"@cloudflare/workers-types\").Request} request\r\n\t * @param {{UUID: string, PROXYIP: string, DNS_RESOLVER_URL: string, NODE_ID: int, API_HOST: string, API_TOKEN: string}} env\r\n\t * @param {import(\"@cloudflare/workers-types\").ExecutionContext} ctx\r\n\t * @returns {Promise<Response>}\r\n\t */\r\n\tasync fetch(request, env, ctx) {\r\n\t\ttry {\r\n\t\t\tuserID = env.UUID || userID;\r\n\t\t\tproxyIP = env.PROXYIP || proxyIP;\r\n\t\t\tdohURL = env.DNS_RESOLVER_URL || dohURL;\r\n\t\t\tnodeId = env.NODE_ID || nodeId;\r\n\t\t\tapiToken = env.API_TOKEN || apiToken;\r\n\t\t\tapiHost = env.API_HOST || apiHost;\r\n\t\t\tlet userID_Path = userID;\r\n\t\t\tif (userID.includes(',')) {\r\n\t\t\t\tuserID_Path = userID.split(',')[0];\r\n\t\t\t}\r\n\t\t\tconst upgradeHeader = request.headers.get('Upgrade');\r\n\t\t\tif (!upgradeHeader || upgradeHeader !== 'websocket') {\r\n\t\t\t\tconst url = new URL(request.url);\r\n\t\t\t\tswitch (url.pathname) {\r\n\t\t\t\t\tcase '/cf':\r\n\t\t\t\t\t\treturn new Response(JSON.stringify(request.cf, null, 4), {\r\n\t\t\t\t\t\t\tstatus: 200,\r\n\t\t\t\t\t\t\theaders: {\r\n\t\t\t\t\t\t\t\t\"Content-Type\": \"application/json;charset=utf-8\",\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\tcase '/connect': // for test connect to cf socket\r\n\t\t\t\t\t\tconst [hostname, port] = ['cloudflare.com', '80'];\r\n\t\t\t\t\t\tconsole.log(`Connecting to ${hostname}:${port}...`);\r\n\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tconst socket = await connect({\r\n\t\t\t\t\t\t\t\thostname: hostname,\r\n\t\t\t\t\t\t\t\tport: parseInt(port, 10),\r\n\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\tconst writer = socket.writable.getWriter();\r\n\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\tawait writer.write(new TextEncoder().encode('GET / HTTP/1.1\\r\\nHost: ' + hostname + '\\r\\n\\r\\n'));\r\n\t\t\t\t\t\t\t} catch (writeError) {\r\n\t\t\t\t\t\t\t\twriter.releaseLock();\r\n\t\t\t\t\t\t\t\tawait socket.close();\r\n\t\t\t\t\t\t\t\treturn new Response(writeError.message, { status: 500 });\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\twriter.releaseLock();\r\n\r\n\t\t\t\t\t\t\tconst reader = socket.readable.getReader();\r\n\t\t\t\t\t\t\tlet value;\r\n\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\tconst result = await reader.read();\r\n\t\t\t\t\t\t\t\tvalue = result.value;\r\n\t\t\t\t\t\t\t} catch (readError) {\r\n\t\t\t\t\t\t\t\tawait reader.releaseLock();\r\n\t\t\t\t\t\t\t\tawait socket.close();\r\n\t\t\t\t\t\t\t\treturn new Response(readError.message, { status: 500 });\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tawait reader.releaseLock();\r\n\t\t\t\t\t\t\tawait socket.close();\r\n\r\n\t\t\t\t\t\t\treturn new Response(new TextDecoder().decode(value), { status: 200 });\r\n\t\t\t\t\t\t} catch (connectError) {\r\n\t\t\t\t\t\t\treturn new Response(connectError.message, { status: 500 });\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\tcase `/${userID_Path}`: {\r\n\t\t\t\t\t\tconst vlessConfig = getVLESSConfig(userID, request.headers.get('Host'));\r\n\t\t\t\t\t\treturn new Response(`${vlessConfig}`, {\r\n\t\t\t\t\t\t\tstatus: 200,\r\n\t\t\t\t\t\t\theaders: {\r\n\t\t\t\t\t\t\t\t\"Content-Type\": \"text/html; charset=utf-8\",\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcase `/sub/${userID_Path}`: {\r\n\t\t\t\t\t\tconst url = new URL(request.url);\r\n\t\t\t\t\t\tconst searchParams = url.searchParams;\r\n\t\t\t\t\t\tlet vlessConfig = createVLESSSub(userID, request.headers.get('Host'));\r\n\r\n\t\t\t\t\t\t// If 'format' query param equals to 'clash', convert config to base64\r\n\t\t\t\t\t\tif (searchParams.get('format') === 'clash') {\r\n\t\t\t\t\t\t\tvlessConfig = btoa(vlessConfig);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Construct and return response object\r\n\t\t\t\t\t\treturn new Response(vlessConfig, {\r\n\t\t\t\t\t\t\tstatus: 200,\r\n\t\t\t\t\t\t\theaders: {\r\n\t\t\t\t\t\t\t\t\"Content-Type\": \"text/plain;charset=utf-8\",\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t// return new Response('Not found', { status: 404 });\r\n\t\t\t\t\t\t// For any other path, reverse proxy to 'www.fmprc.gov.cn' and return the original response\r\n\t\t\t\t\t\turl.hostname = Math.random() < 0.5 ? 'www.gov.cn' : 'www.fmprc.gov.cn';\r\n\t\t\t\t\t\turl.protocol = 'https:';\r\n\t\t\t\t\t\trequest = new Request(url, request);\r\n\t\t\t\t\t\treturn await fetch(request);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\treturn await vlessOverWSHandler(request);\r\n\t\t\t}\r\n\t\t} catch (err) {\r\n\t\t\t/** @type {Error} */ let e = err;\r\n\t\t\treturn new Response(e.toString());\r\n\t\t}\r\n\t},\r\n};\r\n\r\n/**\r\n * Creates a PlanetScale connection object and returns it.\r\n * @param {{DATABASE_HOST: string, DATABASE_USERNAME: string, DATABASE_PASSWORD: string}} env The environment variables containing the database connection information.\r\n * @returns {Promise<object>} A Promise that resolves to the PlanetScale connection object.\r\n */\r\nfunction getPlanetScaleConnection(env) {\r\n\tconst config = {\r\n\t\thost: env.DATABASE_HOST,\r\n\t\tusername: env.DATABASE_USERNAME,\r\n\t\tpassword: env.DATABASE_PASSWORD,\r\n\t\tfetch: (url, init) => {\r\n\t\t\tdelete (init)[\"cache\"];\r\n\t\t\treturn fetch(url, init);\r\n\t\t}\r\n\t}\r\n\treturn connectdb(config)\r\n}\r\n\r\n/**\r\n * Handles VLESS over WebSocket requests by creating a WebSocket pair, accepting the WebSocket connection, and processing the VLESS header.\r\n * @param {import(\"@cloudflare/workers-types\").Request} request The incoming request object.\r\n * @returns {Promise<Response>} A Promise that resolves to a WebSocket response object.\r\n */\r\nasync function vlessOverWSHandler(request) {\r\n\tconst webSocketPair = new WebSocketPair();\r\n\tconst [client, webSocket] = Object.values(webSocketPair);\r\n\twebSocket.accept();\r\n\r\n\tlet address = '';\r\n\tlet portWithRandomLog = '';\r\n\tconst log = (/** @type {string} */ info, /** @type {string | undefined} */ event) => {\r\n\t\tconsole.log(`[${address}:${portWithRandomLog}] ${info}`, event || '');\r\n\t};\r\n\tconst earlyDataHeader = request.headers.get('sec-websocket-protocol') || '';\r\n\r\n\tconst readableWebSocketStream = makeReadableWebSocketStream(webSocket, earlyDataHeader, log);\r\n\r\n\t/** @type {{ value: import(\"@cloudflare/workers-types\").Socket | null}}*/\r\n\tlet remoteSocketWapper = {\r\n\t\tvalue: null,\r\n\t};\r\n\tlet udpStreamWrite = null;\r\n\tlet isDns = false;\r\n\r\n\t// ws --> remote\r\n\treadableWebSocketStream.pipeTo(new WritableStream({\r\n\t\tasync write(chunk, controller) {\r\n\t\t\tif (isDns && udpStreamWrite) {\r\n\t\t\t\treturn udpStreamWrite(chunk);\r\n\t\t\t}\r\n\t\t\tif (remoteSocketWapper.value) {\r\n\t\t\t\tconst writer = remoteSocketWapper.value.writable.getWriter()\r\n\t\t\t\tawait writer.write(chunk);\r\n\t\t\t\twriter.releaseLock();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tconst {\r\n\t\t\t\thasError,\r\n\t\t\t\tmessage,\r\n\t\t\t\tportRemote = 443,\r\n\t\t\t\taddressRemote = '',\r\n\t\t\t\trawDataIndex,\r\n\t\t\t\tvlessVersion = new Uint8Array([0, 0]),\r\n\t\t\t\tisUDP,\r\n\t\t\t} = processVlessHeader(chunk, userID);\r\n\t\t\taddress = addressRemote;\r\n\t\t\tportWithRandomLog = `${portRemote} ${isUDP ? 'udp' : 'tcp'} `;\r\n\t\t\tif (hasError) {\r\n\t\t\t\t// controller.error(message);\r\n\t\t\t\tthrow new Error(message); // cf seems has bug, controller.error will not end stream\r\n\t\t\t\t// webSocket.close(1000, message);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// If UDP and not DNS port, close it\r\n\t\t\tif (isUDP && portRemote !== 53) {\r\n\t\t\t\tthrow new Error('UDP proxy only enabled for DNS which is port 53');\r\n\t\t\t\t// cf seems has bug, controller.error will not end stream\r\n\t\t\t}\r\n\r\n\t\t\tif (isUDP && portRemote === 53) {\r\n\t\t\t\tisDns = true;\r\n\t\t\t}\r\n\r\n\t\t\t// [\"version\", \"\u9644\u52A0\u4FE1\u606F\u957F\u5EA6 N\"]\r\n\t\t\tconst vlessResponseHeader = new Uint8Array([vlessVersion[0], 0]);\r\n\t\t\tconst rawClientData = chunk.slice(rawDataIndex);\r\n\r\n\t\t\t// TODO: support udp here when cf runtime has udp support\r\n\t\t\tif (isDns) {\r\n\t\t\t\tconst { write } = await handleUDPOutBound(webSocket, vlessResponseHeader, log);\r\n\t\t\t\tudpStreamWrite = write;\r\n\t\t\t\tudpStreamWrite(rawClientData);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\thandleTCPOutBound(remoteSocketWapper, addressRemote, portRemote, rawClientData, webSocket, vlessResponseHeader, log);\r\n\t\t},\r\n\t\tclose() {\r\n\t\t\tlog(`readableWebSocketStream is close`);\r\n\t\t},\r\n\t\tabort(reason) {\r\n\t\t\tlog(`readableWebSocketStream is abort`, JSON.stringify(reason));\r\n\t\t},\r\n\t})).catch((err) => {\r\n\t\tlog('readableWebSocketStream pipeTo error', err);\r\n\t});\r\n\r\n\treturn new Response(null, {\r\n\t\tstatus: 101,\r\n\t\twebSocket: client,\r\n\t});\r\n}\r\n\r\nlet apiResponseCache = null;\r\nlet cacheTimeout = null;\r\n\r\n/**\r\n * Fetches the API response from the server and caches it for future use.\r\n * @returns {Promise<object|null>} A Promise that resolves to the API response object or null if there was an error.\r\n */\r\nasync function fetchApiResponse() {\r\n\tconst requestOptions = {\r\n\t\tmethod: 'GET',\r\n\t\tredirect: 'follow'\r\n\t};\r\n\r\n\ttry {\r\n\t\tconst response = await fetch(`https://${apiHost}/api/v1/server/UniProxy/user?node_id=${nodeId}&node_type=v2ray&token=${apiToken}`, requestOptions);\r\n\r\n\t\tif (!response.ok) {\r\n\t\t\tconsole.error('Error: Network response was not ok');\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tconst apiResponse = await response.json();\r\n\t\tapiResponseCache = apiResponse;\r\n\r\n\t\t// Refresh the cache every 5 minutes (300000 milliseconds)\r\n\t\tif (cacheTimeout) {\r\n\t\t\tclearTimeout(cacheTimeout);\r\n\t\t}\r\n\t\tcacheTimeout = setTimeout(() => fetchApiResponse(), 300000);\r\n\r\n\t\treturn apiResponse;\r\n\t} catch (error) {\r\n\t\tconsole.error('Error:', error);\r\n\t\treturn null;\r\n\t}\r\n}\r\n\r\n/**\r\n * Returns the cached API response if it exists, otherwise fetches the API response from the server and caches it for future use.\r\n * @returns {Promise<object|null>} A Promise that resolves to the cached API response object or the fetched API response object, or null if there was an error.\r\n */\r\nasync function getApiResponse() {\r\n\tif (!apiResponseCache) {\r\n\t\treturn await fetchApiResponse();\r\n\t}\r\n\treturn apiResponseCache;\r\n}\r\n\r\n/**\r\n * Checks if a given UUID is present in the API response.\r\n * @param {string} targetUuid The UUID to search for.\r\n * @returns {Promise<boolean>} A Promise that resolves to true if the UUID is present in the API response, false otherwise.\r\n */\r\nasync function checkUuidInApiResponse(targetUuid) {\r\n\t// Check if any of the environment variables are empty\r\n\tif (!nodeId || !apiToken || !apiHost) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\ttry {\r\n\t\tconst apiResponse = await getApiResponse();\r\n\t\tif (!apiResponse) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tconst isUuidInResponse = apiResponse.users.some(user => user.uuid === targetUuid);\r\n\t\treturn isUuidInResponse;\r\n\t} catch (error) {\r\n\t\tconsole.error('Error:', error);\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\n// Usage example:\r\n//   const targetUuid = \"65590e04-a94c-4c59-a1f2-571bce925aad\";\r\n//   checkUuidInApiResponse(targetUuid).then(result => console.log(result));\r\n\r\n/**\r\n * Handles outbound TCP connections.\r\n *\r\n * @param {any} remoteSocket \r\n * @param {string} addressRemote The remote address to connect to.\r\n * @param {number} portRemote The remote port to connect to.\r\n * @param {Uint8Array} rawClientData The raw client data to write.\r\n * @param {import(\"@cloudflare/workers-types\").WebSocket} webSocket The WebSocket to pass the remote socket to.\r\n * @param {Uint8Array} vlessResponseHeader The VLESS response header.\r\n * @param {function} log The logging function.\r\n * @returns {Promise<void>} The remote socket.\r\n */\r\nasync function handleTCPOutBound(remoteSocket, addressRemote, portRemote, rawClientData, webSocket, vlessResponseHeader, log,) {\r\n\r\n\t/**\r\n\t * Connects to a given address and port and writes data to the socket.\r\n\t * @param {string} address The address to connect to.\r\n\t * @param {number} port The port to connect to.\r\n\t * @returns {Promise<import(\"@cloudflare/workers-types\").Socket>} A Promise that resolves to the connected socket.\r\n\t */\r\n\tasync function connectAndWrite(address, port) {\r\n\t\t/** @type {import(\"@cloudflare/workers-types\").Socket} */\r\n\t\tconst tcpSocket = connect({\r\n\t\t\thostname: address,\r\n\t\t\tport: port,\r\n\t\t});\r\n\t\tremoteSocket.value = tcpSocket;\r\n\t\tlog(`connected to ${address}:${port}`);\r\n\t\tconst writer = tcpSocket.writable.getWriter();\r\n\t\tawait writer.write(rawClientData); // first write, nomal is tls client hello\r\n\t\twriter.releaseLock();\r\n\t\treturn tcpSocket;\r\n\t}\r\n\r\n\t/**\r\n\t * Retries connecting to the remote address and port if the Cloudflare socket has no incoming data.\r\n\t * @returns {Promise<void>} A Promise that resolves when the retry is complete.\r\n\t */\r\n\tasync function retry() {\r\n\t\tconst tcpSocket = await connectAndWrite(proxyIP || addressRemote, portRemote)\r\n\t\ttcpSocket.closed.catch(error => {\r\n\t\t\tconsole.log('retry tcpSocket closed error', error);\r\n\t\t}).finally(() => {\r\n\t\t\tsafeCloseWebSocket(webSocket);\r\n\t\t})\r\n\t\tremoteSocketToWS(tcpSocket, webSocket, vlessResponseHeader, null, log);\r\n\t}\r\n\r\n\tconst tcpSocket = await connectAndWrite(addressRemote, portRemote);\r\n\r\n\t// when remoteSocket is ready, pass to websocket\r\n\t// remote--> ws\r\n\tremoteSocketToWS(tcpSocket, webSocket, vlessResponseHeader, retry, log);\r\n}\r\n\r\n/**\r\n * Creates a readable stream from a WebSocket server, allowing for data to be read from the WebSocket.\r\n * @param {import(\"@cloudflare/workers-types\").WebSocket} webSocketServer The WebSocket server to create the readable stream from.\r\n * @param {string} earlyDataHeader The header containing early data for WebSocket 0-RTT.\r\n * @param {(info: string)=> void} log The logging function.\r\n * @returns {ReadableStream} A readable stream that can be used to read data from the WebSocket.\r\n */\r\nfunction makeReadableWebSocketStream(webSocketServer, earlyDataHeader, log) {\r\n\tlet readableStreamCancel = false;\r\n\tconst stream = new ReadableStream({\r\n\t\tstart(controller) {\r\n\t\t\twebSocketServer.addEventListener('message', (event) => {\r\n\t\t\t\tconst message = event.data;\r\n\t\t\t\tcontroller.enqueue(message);\r\n\t\t\t});\r\n\r\n\t\t\twebSocketServer.addEventListener('close', () => {\r\n\t\t\t\tsafeCloseWebSocket(webSocketServer);\r\n\t\t\t\tcontroller.close();\r\n\t\t\t});\r\n\r\n\t\t\twebSocketServer.addEventListener('error', (err) => {\r\n\t\t\t\tlog('webSocketServer has error');\r\n\t\t\t\tcontroller.error(err);\r\n\t\t\t});\r\n\t\t\tconst { earlyData, error } = base64ToArrayBuffer(earlyDataHeader);\r\n\t\t\tif (error) {\r\n\t\t\t\tcontroller.error(error);\r\n\t\t\t} else if (earlyData) {\r\n\t\t\t\tcontroller.enqueue(earlyData);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tpull(controller) {\r\n\t\t\t// if ws can stop read if stream is full, we can implement backpressure\r\n\t\t\t// https://streams.spec.whatwg.org/#example-rs-push-backpressure\r\n\t\t},\r\n\r\n\t\tcancel(reason) {\r\n\t\t\tlog(`ReadableStream was canceled, due to ${reason}`)\r\n\t\t\treadableStreamCancel = true;\r\n\t\t\tsafeCloseWebSocket(webSocketServer);\r\n\t\t}\r\n\t});\r\n\r\n\treturn stream;\r\n}\r\n\r\n// https://xtls.github.io/development/protocols/vless.html\r\n// https://github.com/zizifn/excalidraw-backup/blob/main/v2ray-protocol.excalidraw\r\n\r\n/**\r\n * Processes the VLESS header buffer and returns an object with the relevant information.\r\n * @param {ArrayBuffer} vlessBuffer The VLESS header buffer to process.\r\n * @param {string} userID The user ID to validate against the UUID in the VLESS header.\r\n * @returns {{\r\n *  hasError: boolean,\r\n *  message?: string,\r\n *  addressRemote?: string,\r\n *  addressType?: number,\r\n *  portRemote?: number,\r\n *  rawDataIndex?: number,\r\n *  vlessVersion?: Uint8Array,\r\n *  isUDP?: boolean\r\n * }} An object with the relevant information extracted from the VLESS header buffer.\r\n */\r\nfunction processVlessHeader(vlessBuffer, userID) {\r\n\tif (vlessBuffer.byteLength < 24) {\r\n\t\treturn {\r\n\t\t\thasError: true,\r\n\t\t\tmessage: 'invalid data',\r\n\t\t};\r\n\t}\r\n\tconst version = new Uint8Array(vlessBuffer.slice(0, 1));\r\n\tlet isValidUser = false;\r\n\tlet isUDP = false;\r\n\tconst slicedBuffer = new Uint8Array(vlessBuffer.slice(1, 17));\r\n\tconst slicedBufferString = stringify(slicedBuffer);\r\n\t// check if userID is valid uuid or uuids split by , and contains userID in it otherwise return error message to console\r\n\tconst uuids = userID.includes(',') ? userID.split(\",\") : [userID];\r\n\tconsole.log(slicedBufferString, uuids);\r\n\r\n\t// isValidUser = uuids.some(userUuid => slicedBufferString === userUuid.trim());\r\n\tisValidUser = uuids.some(userUuid => slicedBufferString === userUuid.trim()) || uuids.length === 1 && slicedBufferString === uuids[0].trim();\r\n\r\n\tconsole.log(`userID: ${slicedBufferString}`);\r\n\r\n\tif (!isValidUser) {\r\n\t\treturn {\r\n\t\t\thasError: true,\r\n\t\t\tmessage: 'invalid user',\r\n\t\t};\r\n\t}\r\n\r\n\tconst optLength = new Uint8Array(vlessBuffer.slice(17, 18))[0];\r\n\t//skip opt for now\r\n\r\n\tconst command = new Uint8Array(\r\n\t\tvlessBuffer.slice(18 + optLength, 18 + optLength + 1)\r\n\t)[0];\r\n\r\n\t// 0x01 TCP\r\n\t// 0x02 UDP\r\n\t// 0x03 MUX\r\n\tif (command === 1) {\r\n\t\tisUDP = false;\r\n\t} else if (command === 2) {\r\n\t\tisUDP = true;\r\n\t} else {\r\n\t\treturn {\r\n\t\t\thasError: true,\r\n\t\t\tmessage: `command ${command} is not support, command 01-tcp,02-udp,03-mux`,\r\n\t\t};\r\n\t}\r\n\tconst portIndex = 18 + optLength + 1;\r\n\tconst portBuffer = vlessBuffer.slice(portIndex, portIndex + 2);\r\n\t// port is big-Endian in raw data etc 80 == 0x005d\r\n\tconst portRemote = new DataView(portBuffer).getUint16(0);\r\n\r\n\tlet addressIndex = portIndex + 2;\r\n\tconst addressBuffer = new Uint8Array(\r\n\t\tvlessBuffer.slice(addressIndex, addressIndex + 1)\r\n\t);\r\n\r\n\t// 1--> ipv4  addressLength =4\r\n\t// 2--> domain name addressLength=addressBuffer[1]\r\n\t// 3--> ipv6  addressLength =16\r\n\tconst addressType = addressBuffer[0];\r\n\tlet addressLength = 0;\r\n\tlet addressValueIndex = addressIndex + 1;\r\n\tlet addressValue = '';\r\n\tswitch (addressType) {\r\n\t\tcase 1:\r\n\t\t\taddressLength = 4;\r\n\t\t\taddressValue = new Uint8Array(\r\n\t\t\t\tvlessBuffer.slice(addressValueIndex, addressValueIndex + addressLength)\r\n\t\t\t).join('.');\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\taddressLength = new Uint8Array(\r\n\t\t\t\tvlessBuffer.slice(addressValueIndex, addressValueIndex + 1)\r\n\t\t\t)[0];\r\n\t\t\taddressValueIndex += 1;\r\n\t\t\taddressValue = new TextDecoder().decode(\r\n\t\t\t\tvlessBuffer.slice(addressValueIndex, addressValueIndex + addressLength)\r\n\t\t\t);\r\n\t\t\tbreak;\r\n\t\tcase 3:\r\n\t\t\taddressLength = 16;\r\n\t\t\tconst dataView = new DataView(\r\n\t\t\t\tvlessBuffer.slice(addressValueIndex, addressValueIndex + addressLength)\r\n\t\t\t);\r\n\t\t\t// 2001:0db8:85a3:0000:0000:8a2e:0370:7334\r\n\t\t\tconst ipv6 = [];\r\n\t\t\tfor (let i = 0; i < 8; i++) {\r\n\t\t\t\tipv6.push(dataView.getUint16(i * 2).toString(16));\r\n\t\t\t}\r\n\t\t\taddressValue = ipv6.join(':');\r\n\t\t\t// seems no need add [] for ipv6\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\treturn {\r\n\t\t\t\thasError: true,\r\n\t\t\t\tmessage: `invild  addressType is ${addressType}`,\r\n\t\t\t};\r\n\t}\r\n\tif (!addressValue) {\r\n\t\treturn {\r\n\t\t\thasError: true,\r\n\t\t\tmessage: `addressValue is empty, addressType is ${addressType}`,\r\n\t\t};\r\n\t}\r\n\r\n\treturn {\r\n\t\thasError: false,\r\n\t\taddressRemote: addressValue,\r\n\t\taddressType,\r\n\t\tportRemote,\r\n\t\trawDataIndex: addressValueIndex + addressLength,\r\n\t\tvlessVersion: version,\r\n\t\tisUDP,\r\n\t};\r\n}\r\n\r\n\r\n/**\r\n * Converts a remote socket to a WebSocket connection.\r\n * @param {import(\"@cloudflare/workers-types\").Socket} remoteSocket The remote socket to convert.\r\n * @param {import(\"@cloudflare/workers-types\").WebSocket} webSocket The WebSocket to connect to.\r\n * @param {ArrayBuffer | null} vlessResponseHeader The VLESS response header.\r\n * @param {(() => Promise<void>) | null} retry The function to retry the connection if it fails.\r\n * @param {(info: string) => void} log The logging function.\r\n * @returns {Promise<void>} A Promise that resolves when the conversion is complete.\r\n */\r\nasync function remoteSocketToWS(remoteSocket, webSocket, vlessResponseHeader, retry, log) {\r\n\t// remote--> ws\r\n\tlet remoteChunkCount = 0;\r\n\tlet chunks = [];\r\n\t/** @type {ArrayBuffer | null} */\r\n\tlet vlessHeader = vlessResponseHeader;\r\n\tlet hasIncomingData = false; // check if remoteSocket has incoming data\r\n\tawait remoteSocket.readable\r\n\t\t.pipeTo(\r\n\t\t\tnew WritableStream({\r\n\t\t\t\tstart() {\r\n\t\t\t\t},\r\n\t\t\t\t/**\r\n\t\t\t\t * \r\n\t\t\t\t * @param {Uint8Array} chunk \r\n\t\t\t\t * @param {*} controller \r\n\t\t\t\t */\r\n\t\t\t\tasync write(chunk, controller) {\r\n\t\t\t\t\thasIncomingData = true;\r\n\t\t\t\t\tremoteChunkCount++;\r\n\t\t\t\t\tif (webSocket.readyState !== WS_READY_STATE_OPEN) {\r\n\t\t\t\t\t\tcontroller.error(\r\n\t\t\t\t\t\t\t'webSocket.readyState is not open, maybe close'\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (vlessHeader) {\r\n\t\t\t\t\t\twebSocket.send(await new Blob([vlessHeader, chunk]).arrayBuffer());\r\n\t\t\t\t\t\tvlessHeader = null;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tconsole.log(`remoteSocketToWS send chunk ${chunk.byteLength}`);\r\n\t\t\t\t\t\t// seems no need rate limit this, CF seems fix this??..\r\n\t\t\t\t\t\t// if (remoteChunkCount > 20000) {\r\n\t\t\t\t\t\t// \t// cf one package is 4096 byte(4kb),  4096 * 20000 = 80M\r\n\t\t\t\t\t\t// \tawait delay(1);\r\n\t\t\t\t\t\t// }\r\n\t\t\t\t\t\twebSocket.send(chunk);\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tclose() {\r\n\t\t\t\t\tlog(`remoteConnection!.readable is close with hasIncomingData is ${hasIncomingData}`);\r\n\t\t\t\t\t// safeCloseWebSocket(webSocket); // no need server close websocket frist for some case will casue HTTP ERR_CONTENT_LENGTH_MISMATCH issue, client will send close event anyway.\r\n\t\t\t\t},\r\n\t\t\t\tabort(reason) {\r\n\t\t\t\t\tconsole.error(`remoteConnection!.readable abort`, reason);\r\n\t\t\t\t},\r\n\t\t\t})\r\n\t\t)\r\n\t\t.catch((error) => {\r\n\t\t\tconsole.error(\r\n\t\t\t\t`remoteSocketToWS has exception `,\r\n\t\t\t\terror.stack || error\r\n\t\t\t);\r\n\t\t\tsafeCloseWebSocket(webSocket);\r\n\t\t});\r\n\r\n\t// seems is cf connect socket have error,\r\n\t// 1. Socket.closed will have error\r\n\t// 2. Socket.readable will be close without any data coming\r\n\tif (hasIncomingData === false && retry) {\r\n\t\tlog(`retry`)\r\n\t\tretry();\r\n\t}\r\n}\r\n\r\n/**\r\n * Decodes a base64 string into an ArrayBuffer.\r\n * @param {string} base64Str The base64 string to decode.\r\n * @returns {{earlyData: ArrayBuffer|null, error: Error|null}} An object containing the decoded ArrayBuffer or null if there was an error, and any error that occurred during decoding or null if there was no error.\r\n */\r\nfunction base64ToArrayBuffer(base64Str) {\r\n\tif (!base64Str) {\r\n\t\treturn { earlyData: null, error: null };\r\n\t}\r\n\ttry {\r\n\t\t// go use modified Base64 for URL rfc4648 which js atob not support\r\n\t\tbase64Str = base64Str.replace(/-/g, '+').replace(/_/g, '/');\r\n\t\tconst decode = atob(base64Str);\r\n\t\tconst arryBuffer = Uint8Array.from(decode, (c) => c.charCodeAt(0));\r\n\t\treturn { earlyData: arryBuffer.buffer, error: null };\r\n\t} catch (error) {\r\n\t\treturn { earlyData: null, error };\r\n\t}\r\n}\r\n\r\n/**\r\n * Checks if a given string is a valid UUID.\r\n * Note: This is not a real UUID validation.\r\n * @param {string} uuid The string to validate as a UUID.\r\n * @returns {boolean} True if the string is a valid UUID, false otherwise.\r\n */\r\nfunction isValidUUID(uuid) {\r\n\tconst uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\r\n\treturn uuidRegex.test(uuid);\r\n}\r\n\r\nconst WS_READY_STATE_OPEN = 1;\r\nconst WS_READY_STATE_CLOSING = 2;\r\n/**\r\n * Closes a WebSocket connection safely without throwing exceptions.\r\n * @param {import(\"@cloudflare/workers-types\").WebSocket} socket The WebSocket connection to close.\r\n */\r\nfunction safeCloseWebSocket(socket) {\r\n\ttry {\r\n\t\tif (socket.readyState === WS_READY_STATE_OPEN || socket.readyState === WS_READY_STATE_CLOSING) {\r\n\t\t\tsocket.close();\r\n\t\t}\r\n\t} catch (error) {\r\n\t\tconsole.error('safeCloseWebSocket error', error);\r\n\t}\r\n}\r\n\r\nconst byteToHex = [];\r\n\r\nfor (let i = 0; i < 256; ++i) {\r\n\tbyteToHex.push((i + 256).toString(16).slice(1));\r\n}\r\n\r\nfunction unsafeStringify(arr, offset = 0) {\r\n\treturn (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + \"-\" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + \"-\" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + \"-\" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + \"-\" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\r\n}\r\n\r\nfunction stringify(arr, offset = 0) {\r\n\tconst uuid = unsafeStringify(arr, offset);\r\n\tif (!isValidUUID(uuid)) {\r\n\t\tthrow TypeError(\"Stringified UUID is invalid\");\r\n\t}\r\n\treturn uuid;\r\n}\r\n\r\n\r\n/**\r\n * Handles outbound UDP traffic by transforming the data into DNS queries and sending them over a WebSocket connection.\r\n * @param {import(\"@cloudflare/workers-types\").WebSocket} webSocket The WebSocket connection to send the DNS queries over.\r\n * @param {ArrayBuffer} vlessResponseHeader The VLESS response header.\r\n * @param {(string) => void} log The logging function.\r\n * @returns {{write: (chunk: Uint8Array) => void}} An object with a write method that accepts a Uint8Array chunk to write to the transform stream.\r\n */\r\nasync function handleUDPOutBound(webSocket, vlessResponseHeader, log) {\r\n\r\n\tlet isVlessHeaderSent = false;\r\n\tconst transformStream = new TransformStream({\r\n\t\tstart(controller) {\r\n\r\n\t\t},\r\n\t\ttransform(chunk, controller) {\r\n\t\t\t// udp message 2 byte is the the length of udp data\r\n\t\t\t// TODO: this should have bug, beacsue maybe udp chunk can be in two websocket message\r\n\t\t\tfor (let index = 0; index < chunk.byteLength;) {\r\n\t\t\t\tconst lengthBuffer = chunk.slice(index, index + 2);\r\n\t\t\t\tconst udpPakcetLength = new DataView(lengthBuffer).getUint16(0);\r\n\t\t\t\tconst udpData = new Uint8Array(\r\n\t\t\t\t\tchunk.slice(index + 2, index + 2 + udpPakcetLength)\r\n\t\t\t\t);\r\n\t\t\t\tindex = index + 2 + udpPakcetLength;\r\n\t\t\t\tcontroller.enqueue(udpData);\r\n\t\t\t}\r\n\t\t},\r\n\t\tflush(controller) {\r\n\t\t}\r\n\t});\r\n\r\n\t// only handle dns udp for now\r\n\ttransformStream.readable.pipeTo(new WritableStream({\r\n\t\tasync write(chunk) {\r\n\t\t\tconst resp = await fetch(dohURL, // dns server url\r\n\t\t\t\t{\r\n\t\t\t\t\tmethod: 'POST',\r\n\t\t\t\t\theaders: {\r\n\t\t\t\t\t\t'content-type': 'application/dns-message',\r\n\t\t\t\t\t},\r\n\t\t\t\t\tbody: chunk,\r\n\t\t\t\t})\r\n\t\t\tconst dnsQueryResult = await resp.arrayBuffer();\r\n\t\t\tconst udpSize = dnsQueryResult.byteLength;\r\n\t\t\t// console.log([...new Uint8Array(dnsQueryResult)].map((x) => x.toString(16)));\r\n\t\t\tconst udpSizeBuffer = new Uint8Array([(udpSize >> 8) & 0xff, udpSize & 0xff]);\r\n\t\t\tif (webSocket.readyState === WS_READY_STATE_OPEN) {\r\n\t\t\t\tlog(`doh success and dns message length is ${udpSize}`);\r\n\t\t\t\tif (isVlessHeaderSent) {\r\n\t\t\t\t\twebSocket.send(await new Blob([udpSizeBuffer, dnsQueryResult]).arrayBuffer());\r\n\t\t\t\t} else {\r\n\t\t\t\t\twebSocket.send(await new Blob([vlessResponseHeader, udpSizeBuffer, dnsQueryResult]).arrayBuffer());\r\n\t\t\t\t\tisVlessHeaderSent = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t})).catch((error) => {\r\n\t\tlog('dns udp has error' + error)\r\n\t});\r\n\r\n\tconst writer = transformStream.writable.getWriter();\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * \r\n\t\t * @param {Uint8Array} chunk \r\n\t\t */\r\n\t\twrite(chunk) {\r\n\t\t\twriter.write(chunk);\r\n\t\t}\r\n\t};\r\n}\r\n\r\n/**\r\n *\r\n * @param {string} userID - single or comma separated userIDs\r\n * @param {string | null} hostName\r\n * @returns {string}\r\n */\r\nfunction getVLESSConfig(userIDs, hostName) {\r\n\tconst commonUrlPart = `:443?encryption=none&security=tls&sni=${hostName}&type=ws&host=${hostName}&path=%2F%3Fed%3D2048#${hostName}`;\r\n\tconst separator = \"---------------------------------------------------------------\";\r\n\tconst hashSeparator = \"################################################################\";\r\n\r\n\t// Split the userIDs into an array\r\n\tlet userIDArray = userIDs.split(',');\r\n\r\n\t// Prepare output array\r\n\tlet output = [];\r\n\tlet header = [];\r\n\r\n\theader.push(`\\n<p align=\"right\" style=\"direction: rtl; text-align: right;\">\r\n\t<img src=\"https://fa.shafaqna.com/media/2023/02/%D9%88%D8%B2%DB%8C%D8%B1-%D8%A7%D8%B1%D8%AA%D8%A8%D8%A7%D8%B7%D8%A7%D8%AA.jpg\" alt=\"description\" style=\"width: 25%; height: 30%;\">\r\n</p>`);\r\nheader.push(`\\n<p align=\"right\" style=\"direction: rtl; text-align: right; font-size: 15px;\" >\uD83D\uDC4B\u062E\u0648\u0634 \u0622\u0645\u062F\u06CC\u062F: \u0628\u0627 \u0627\u06CC\u0646\u06A9\u0647 \u0633\u0631\u06CC\u0639\u062A\u0631\u06CC\u0646 \u0627\u06CC\u0646\u062A\u0631\u0646\u062A (\u062F\u0627\u062E\u0644\u06CC) \u0631\u0648 \u062F\u0631 \u0633\u0637\u062D \u0627\u0633\u062A\u0627\u0646 \u062F\u0627\u0631\u06CC\u0645 \u0645\u06CC\u062A\u0648\u0627\u0646\u06CC\u062F \u0627\u0632 \u06A9\u0627\u0646\u0641\u06CC\u06AF \u0647\u0627\u06CC Vless \u0632\u06CC\u0631 \u0628\u0631\u0627\u06CC \u06A9\u0627\u0647\u0634 \u0633\u0631\u0639\u062A \u062C\u0647\u062A \u062C\u0644\u0648\u06AF\u06CC\u0631\u06CC \u0627\u0632 \u062A\u0635\u0627\u062F\u0641\u0627\u062A \u0627\u06CC\u0646\u062A\u0631\u0646\u062A\u06CC \u0627\u0633\u062A\u0641\u0627\u062F\u0647 \u06A9\u0646\u06CC\u062F.</p>\\n`);\r\nheader.push(`<p align=\"right\" style=\"direction: rtl; text-align: right; font-size: 15px;\" >\u0627\u06AF\u0631 \u06A9\u0627\u0646\u0641\u06CC\u06AF \u0647\u0627\u06CC VLESS \u0628\u0631\u0627\u062A \u06A9\u0627\u0631 \u06A9\u0631\u062F \u0645\u06CC\u062A\u0648\u0646\u06CC \u0628\u0647 \u0627\u06CC\u0646 \u0628\u0631\u0646\u0627\u0645\u0647 \u06CC\u06A9 \u0633\u062A\u0627\u0631\u0647 \uD83C\uDF1F \u0628\u062F\u06CC.</p>\\n`);\r\nheader.push(`\\n<p align=\"right\" style=\"direction: rtl; text-align: right;\"><a href=\"https://github.com/Ptechgithub/pp-worker\" target=\"_blank\">pp-worker - https://github.com/Ptechgithub/pp-worker</a></p>\\n`);\r\nheader.push(`\\n<p align=\"right\" style=\"direction: rtl; text-align: right;\"><iframe src=\"https://ghbtns.com/github-btn.html?user=USERNAME&repo=REPOSITORY&type=star&count=true&size=large\" frameborder=\"0\" scrolling=\"0\" width=\"170\" height=\"30\" title=\"GitHub\"></iframe></p>\\n\\n`.replace(/USERNAME/g, \"Ptechgithub\").replace(/REPOSITORY/g, \"pp-worker\"));\r\nheader.push(`<p align=\"right\" style=\"direction: rtl; text-align: right;\"><a href=\"//${hostName}/sub/${userIDArray[0]}\" target=\"_blank\">\u2705\uFE0F \u0644\u06CC\u0633\u062A \u06A9\u0627\u0646\u0641\u06CC\u06AF \u0647\u0627\u06CC VLESS</a></p>\\n<p align=\"right\" style=\"direction: rtl; text-align: right;\"><a href=\"https://subconverter.do.xn--b6gac.eu.org/sub?target=clash&url=https://${hostName}/sub/${userIDArray[0]}?format=clash&insert=false&emoji=true&list=false&tfo=false&scv=true&fdn=false&sort=false&new_name=true\" target=\"_blank\">\u2705\uFE0F \u0644\u06CC\u0633\u062A \u06A9\u0627\u0646\u0641\u06CC\u06AF \u0647\u0627\u06CC CLASH</a></p>\\n`);\r\nheader.push(``);\r\n\r\n\r\n\r\n\t// Generate output string for each userID\r\n\tuserIDArray.forEach((userID) => {\r\n\t\tconst vlessMain = `vless://${userID}@${hostName}${commonUrlPart}`;\r\n\t\tconst vlessSec = `vless://${userID}@${proxyIP}${commonUrlPart}`;\r\n\t\toutput.push(`UUID: ${userID}`);\r\n\t\toutput.push(`${hashSeparator}\\nv2ray default ip\\n\uD83D\uDCAB \u06A9\u0627\u0646\u0641\u06CC\u06AF \u0628\u0627 \u062F\u0627\u0645\u06CC\u0646 \u067E\u06CC\u0634 \u0641\u0631\u0636\\n${separator}\\n1\uFE0F\u20E3\\n${vlessMain}\\n${separator}`);\r\n\t\toutput.push(`${hashSeparator}\\nv2ray with best ip\\n\uD83C\uDF1F \u06A9\u0627\u0646\u0641\u06CC\u06AF \u0628\u0627 \u0622\u06CC \u067E\u06CC \u0633\u0627\u0644\u0645 \u06A9\u0644\u0648\u062F\u0641\u0644\u0631\\n${separator}\\n2\uFE0F\u20E3\\n${vlessSec}\\n${separator}`);\r\n\t});\r\n\toutput.push(`${hashSeparator}\\n# Clash Proxy Provider configuration format\\nproxy-groups:\\n  - name: UseProvider\\n\ttype: select\\n\tuse:\\n\t  - provider1\\n\tproxies:\\n\t  - Proxy\\n\t  - DIRECT\\nproxy-providers:\\n  provider1:\\n\ttype: http\\n\turl: https://${hostName}/sub/${userIDArray[0]}?format=clash\\n\tinterval: 3600\\n\tpath: ./provider1.yaml\\n\thealth-check:\\n\t  enable: true\\n\t  interval: 600\\n\t  # lazy: true\\n\t  url: http://www.gstatic.com/generate_204\\n\\n${hashSeparator}`);\r\n\r\n\t// HTML Head with CSS\r\n\tconst htmlHead = `\r\n    <head>\r\n        <title>pp-worker: VLESS configuration</title>\r\n        <meta name=\"description\" content=\"This is a tool for generating VLESS protocol configurations. Give us a star on GitHub https://github.com/Ptechgithub/pp-worker if you found it useful!\">\r\n\t\t<meta name=\"keywords\" content=\"pp-worker, cloudflare pages, cloudflare worker, severless\">\r\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\r\n\t\t<meta property=\"og:site_name\" content=\"pp-worker: VLESS configuration\" />\r\n        <meta property=\"og:type\" content=\"website\" />\r\n        <meta property=\"og:title\" content=\"pp-worker - VLESS configuration and subscribe output\" />\r\n        <meta property=\"og:description\" content=\"Use cloudflare pages and worker severless to implement vless protocol\" />\r\n        <meta property=\"og:url\" content=\"https://${hostName}/\" />\r\n        <meta property=\"og:image\" content=\"https://api.qrserver.com/v1/create-qr-code/?size=500x500&data=${encodeURIComponent(`vless://${userIDs.split(',')[0]}@${hostName}${commonUrlPart}`)}\" />\r\n        <meta name=\"twitter:card\" content=\"summary_large_image\" />\r\n        <meta name=\"twitter:title\" content=\"pp-worker - VLESS configuration and subscribe output\" />\r\n        <meta name=\"twitter:description\" content=\"Use cloudflare pages and worker severless to implement vless protocol\" />\r\n        <meta name=\"twitter:url\" content=\"https://${hostName}/\" />\r\n        <meta name=\"twitter:image\" content=\"https://cloudflare-ipfs.com/ipfs/bafybeigd6i5aavwpr6wvnwuyayklq3omonggta4x2q7kpmgafj357nkcky\" />\r\n        <meta property=\"og:image:width\" content=\"1500\" />\r\n        <meta property=\"og:image:height\" content=\"1500\" />\r\n\r\n        <style>\r\n        body {\r\n            font-family: Arial, sans-serif;\r\n            background-color: #f0f0f0;\r\n            color: #333;\r\n            padding: 10px;\r\n        }\r\n\r\n        a {\r\n            color: #1a0dab;\r\n            text-decoration: none;\r\n        }\r\n\t\timg {\r\n\t\t\tmax-width: 100%;\r\n\t\t\theight: auto;\r\n\t\t}\r\n\t\t\r\n        pre {\r\n            white-space: pre-wrap;\r\n            word-wrap: break-word;\r\n            background-color: #fff;\r\n            border: 1px solid #ddd;\r\n            padding: 15px;\r\n            margin: 10px 0;\r\n        }\r\n\t\t/* Dark mode */\r\n        @media (prefers-color-scheme: dark) {\r\n            body {\r\n                background-color: #333;\r\n                color: #f0f0f0;\r\n            }\r\n\r\n            a {\r\n                color: #9db4ff;\r\n            }\r\n\r\n            pre {\r\n                background-color: #282a36;\r\n                border-color: #6272a4;\r\n            }\r\n        }\r\n        </style>\r\n    </head>\r\n    `;\r\n\r\n\t// Join output with newlines, wrap inside <html> and <body>\r\n\treturn `\r\n    <html>\r\n    ${htmlHead}\r\n    <body>\r\n    <pre style=\"\r\n    background-color: transparent;\r\n    border: none;\r\n\">${header.join('')}</pre><pre>${output.join('\\n')}</pre>\r\n    </body>\r\n</html>`;\r\n}\r\n\r\n\r\nfunction createVLESSSub(userID_Path, hostName) {\r\n\tlet portArray_http = [80, 8080, 8880, 2052, 2086, 2095];\r\n\tlet portArray_https = [443, 8443, 2053, 2096, 2087, 2083];\r\n\r\n\t// Split the userIDs into an array\r\n\tlet userIDArray = userID_Path.includes(',') ? userID_Path.split(',') : [userID_Path];\r\n\r\n\t// Prepare output array\r\n\tlet output = [];\r\n\r\n\t// Generate output string for each userID\r\n\tuserIDArray.forEach((userID) => {\r\n\t\t// Check if the hostName is a Cloudflare Pages domain, if not, generate HTTP configurations\r\n\t\t// reasons: pages.dev not support http only https\r\n\t\tif (!hostName.includes('pages.dev')) {\r\n\t\t\t// Iterate over all ports for http\r\n\t\t\tportArray_http.forEach((port) => {\r\n\t\t\t\tconst commonUrlPart_http = `:${port}?encryption=none&security=none&type=ws&host=${hostName}&path=%2F%3Fed%3D2048#${hostName}-HTTP`;\r\n\t\t\t\tconst vlessMainHttp = `vless://${userID}@${hostName}${commonUrlPart_http}`;\r\n\r\n\t\t\t\t// For each proxy IP, generate a VLESS configuration and add to output\r\n\t\t\t\tproxyIPs.forEach((proxyIP) => {\r\n\t\t\t\t\tconst vlessSecHttp = `vless://${userID}@${proxyIP}${commonUrlPart_http}-${proxyIP}-pp-worker`;\r\n\t\t\t\t\toutput.push(`${vlessMainHttp}`);\r\n\t\t\t\t\toutput.push(`${vlessSecHttp}`);\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t}\r\n\t\t// Iterate over all ports for https\r\n\t\tportArray_https.forEach((port) => {\r\n\t\t\tconst commonUrlPart_https = `:${port}?encryption=none&security=tls&sni=${hostName}&type=ws&host=${hostName}&path=%2F%3Fed%3D2048#${hostName}-HTTPS`;\r\n\t\t\tconst vlessMainHttps = `vless://${userID}@${hostName}${commonUrlPart_https}`;\r\n\r\n\t\t\t// For each proxy IP, generate a VLESS configuration and add to output\r\n\t\t\tproxyIPs.forEach((proxyIP) => {\r\n\t\t\t\tconst vlessSecHttps = `vless://${userID}@${proxyIP}${commonUrlPart_https}-${proxyIP}-pp-worker`;\r\n\t\t\t\toutput.push(`${vlessMainHttps}`);\r\n\t\t\t\toutput.push(`${vlessSecHttps}`);\r\n\t\t\t});\r\n\t\t});\r\n\t});\r\n\r\n\t// Join output with newlines\r\n\treturn output.join('\\n');\r\n}\r\n"],
  "mappings": "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",
  "names": ["connect", "userID", "proxyIPs", "proxyIP", "dohURL", "nodeId", "apiToken", "apiHost", "isValidUUID", "worker_default", "request", "env", "ctx", "userID_Path", "upgradeHeader", "url", "hostname", "port", "socket", "writer", "writeError", "reader", "value", "readError", "connectError", "vlessConfig", "getVLESSConfig", "searchParams", "createVLESSSub", "vlessOverWSHandler", "err", "e", "vlessOverWSHandler", "request", "webSocketPair", "client", "webSocket", "address", "portWithRandomLog", "log", "info", "event", "earlyDataHeader", "readableWebSocketStream", "makeReadableWebSocketStream", "remoteSocketWapper", "udpStreamWrite", "isDns", "chunk", "controller", "writer", "hasError", "message", "portRemote", "addressRemote", "rawDataIndex", "vlessVersion", "isUDP", "processVlessHeader", "userID", "vlessResponseHeader", "rawClientData", "write", "handleUDPOutBound", "handleTCPOutBound", "reason", "err", "handleTCPOutBound", "remoteSocket", "addressRemote", "portRemote", "rawClientData", "webSocket", "vlessResponseHeader", "log", "connectAndWrite", "address", "port", "tcpSocket", "connect", "writer", "retry", "proxyIP", "error", "safeCloseWebSocket", "remoteSocketToWS", "makeReadableWebSocketStream", "webSocketServer", "earlyDataHeader", "readableStreamCancel", "controller", "event", "message", "err", "earlyData", "base64ToArrayBuffer", "reason", "processVlessHeader", "vlessBuffer", "userID", "version", "isValidUser", "isUDP", "slicedBuffer", "slicedBufferString", "stringify", "uuids", "userUuid", "optLength", "command", "portIndex", "portBuffer", "addressIndex", "addressType", "addressLength", "addressValueIndex", "addressValue", "dataView", "ipv6", "i", "remoteChunkCount", "chunks", "vlessHeader", "hasIncomingData", "chunk", "WS_READY_STATE_OPEN", "base64Str", "decode", "isValidUUID", "uuid", "WS_READY_STATE_CLOSING", "socket", "byteToHex", "unsafeStringify", "arr", "offset", "handleUDPOutBound", "isVlessHeaderSent", "transformStream", "index", "lengthBuffer", "udpPakcetLength", "udpData", "dnsQueryResult", "dohURL", "udpSize", "udpSizeBuffer", "getVLESSConfig", "userIDs", "hostName", "commonUrlPart", "separator", "hashSeparator", "userIDArray", "output", "header", "vlessMain", "vlessSec", "createVLESSSub", "userID_Path", "portArray_http", "portArray_https", "commonUrlPart_http", "vlessMainHttp", "proxyIPs", "vlessSecHttp", "commonUrlPart_https", "vlessMainHttps", "vlessSecHttps"]
}
